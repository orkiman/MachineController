MachineController - MachineCore Isolation Refactor Plan (+ Timers Option A)

Overview
- Primary: isolate machine logic in a pluggable MachineCore; Logic orchestrates I/O and side-effects.
- Secondary: Timers Option A (per-cycle edge capture + single output write) supporting the pipeline.

Key Files and Symbols
- src/Logic.cpp: oneLogicCycle(), startTimer(), stopTimer()
- include/Logic.h: core_ member, timer helpers declarations
- include/machine/MachineCore.h: CycleInputs, CycleEffects, TimerCmd, CommCellMessage API
- src/machine/DefaultMachineCore.cpp: DefaultMachineCore implementation + factory
- CMakeLists.txt: added src/machine/DefaultMachineCore.cpp to SOURCES

Logic Cycle Pipeline (Core-Orchestrator Model)
1) Build inputs:
   - inputs: inputChannels_
   - timerEdges: for each timers_[name], capture eventType_ (Rising/Falling) into CycleInputs.timerEdges
   - cellMsgs: consume communicationDataLists_ for all ports (vector offsets represent cell index)
   - blinkLed0: pass UI flag for core logic
2) Core step:
   - fx = core_->step(CycleInputs)
3) Apply effects:
   - Outputs: apply fx.outputChanges to outputChannels_; defer single write
   - Timers: for each fx.timerCmds
       * Start: optional duration override via setDuration(); startTimer(name)
       * Stop: stopTimer(name)
   - Communications: send each fx.commSends via activeCommPorts_[port].send(data)
   - Calibration: if fx.calibration present, emit calibrationResponse(pulsesPerPage, port)
4) Write outputs once:
   - if (!overrideOutputs_ && outputsUpdated_) writeOutputs()
5) Cleanup for next cycle:
   - reset timers_[*].eventType_ to None and state_ = 0
   - inputsUpdated_ = false; commUpdated_ reset when consumed

Timers Option A (supporting tactic)
- TimerEvent handler sets: timers_[name].state_ = 1; eventType_ = Rising; then runs oneLogicCycle()
- startTimer(name): starts Timer with duration (ms) and callback pushing TimerEvent{name}
- stopTimer(name): cancels Timer

Communication Handling
- communicationDataLists_[port] is a vector used as per-port, per-offset mailboxes
- oneLogicCycle consumes all non-empty entries into CycleInputs.cellMsgs and then clears the lists

What Changed (Quick Map)
- Refactor: Isolated decision logic into MachineCore::step; Logic now aggregates inputs and applies side-effects.
- Pipeline: CycleInputs -> core_->step -> CycleEffects -> apply (single write per cycle).
- Timers: Adopted Option A (edge capture/consume) + startTimer/stopTimer helpers.
- Misc: Added json.hpp include; CMake now compiles src/machine/DefaultMachineCore.cpp

Next Steps (to continue after restart)
1) Configure Qt for build (only once per environment):
   - PowerShell from project root:
     cmake -S . -B build -D CMAKE_PREFIX_PATH="C:/Qt/6.9.1/msvc2022_64/lib/cmake"
     cmake --build build --config Debug
   - Adjust the path above if Qt is installed elsewhere (needs Qt6Config.cmake)

2) Run and smoke-test timers Option A:
   - In GUI, toggle variable target "blinkLed0" (SetVariable event)
   - Expect: timer1 starts; on timer1 rising edge core sets o0; outputs written once per cycle
   - Verify logs: "Applying output changes" occurs at most once per cycle

3) Validate communication/calibration flow:
   - Simulate incoming message on an active port: {"type":"calibration_result","pulsesPerPage":12345}
   - Expect: GUI signal calibrationResponse(12345, port) emitted once; comm buffer cleared each cycle

4) Edge-case checks:
   - Confirm that enabling blink re-primes timer1; disabling cancels it
   - Verify that overrideOutputs_ true prevents automatic writeOutputs()

5) Cleanup and follow-ups:
   - Remove any unused includes
   - Add more unit/logic tests inside DefaultMachineCore as the machine logic grows
   - Consider additional timers/ports wiring if needed

Quick Resume Checklist
- Build with correct Qt path
- Launch app
- Toggle blinkLed0 and observe o0 behavior
- Send calibration_result and confirm UI reaction
- Review logs for single write per cycle and timer edge resets
